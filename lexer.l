%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h> // For isatty
#include "parser.tab.h" // Generated by Yacc/Bison
#include "symbol_table.h" // Include the symbol table

/* For Windows compatibility, as unistd.h is not available */
#define YY_NO_UNISTD_H 1

// Forward declaration for the parser
void yyerror(const char *s);

// Define token names for printing
int line_count = 1;
int comment_start_line = 0;

char string_buffer[4096];
char *string_buffer_ptr;

// Updated to print line numbers
void print_token(int line, const char *token_type, const char *text) {
    printf("L%-4d %-25s : %s\n", line, token_type, text);
}

void print_error(int line, const char *error_type, const char *text) {
    fprintf(stderr, "Error on line %d: %s %s\n", line, error_type, text);
}

int yywrap(void);
%}

%x IN_COMMENT
%x IN_STRING

/*Define regex for identifier */
ID      [a-zA-Z_][a-zA-Z0-9_]*

/* Integer constants (decimal, octal, hex) */
INT_CONST       0[xX][0-9a-fA-F]+|0[0-7]*|[1-9][0-9]*

/* Floating constants (simplified)*/
FLOAT_CONST     ([0-9]+\.[0-9]*([eE][+-]?[0-9]+)?)|([0-9]+[eE][+-]?[0-9]+)

/* Character constants (simple)*/
CHAR_CONST      (\'([^\'\\]|\\.)\')

%%
"/*"         { comment_start_line = line_count; BEGIN(IN_COMMENT); }
<IN_COMMENT>{
"*/"       { BEGIN(INITIAL); }
\n         { line_count++; }
.          { /* Eat up comment characters */ }
<<EOF>>    { print_error(comment_start_line, "Unterminated multi-line comment starting on line", ""); exit(1); }
}

\"           { 
    string_buffer_ptr = string_buffer; 
    *string_buffer_ptr = '\0'; 
    BEGIN(IN_STRING); 
}
<IN_STRING>{
\"           { *string_buffer_ptr = '\0'; 
               yylval.str = strdup(string_buffer);
               BEGIN(INITIAL);
               return STRING_LITERAL; }
([^\\\"\n]+) { strcpy(string_buffer_ptr, yytext); string_buffer_ptr += yyleng; }
(\\\")      { strcpy(string_buffer_ptr, yytext); string_buffer_ptr += yyleng; }
(\\[^\"])   { strcpy(string_buffer_ptr, yytext); string_buffer_ptr += yyleng; }
\n          { print_error(line_count, "Unterminated string literal", ""); 
              line_count++;
              BEGIN(INITIAL); }
<<EOF>>     { print_error(line_count, "Unterminated string literal at end of file", "");               exit(1); }
}
\n                   { line_count++; } // Increment line counter
[ \t\r]+             ;   // skip other whitespace
"//".*               { /* skip single line comment, but it might contain a \n at the end, which the next rule will catch */ }
"#".*                { /* skip preprocessor directives */ }  
"break"              { return KEYWORD_BREAK; }
"case"               { return KEYWORD_CASE; }
"char"               { yylval.str = strdup(yytext); return KEYWORD_CHAR; }
"const"              { return KEYWORD_CONST; }
"continue"           { return KEYWORD_CONTINUE; }
"default"            { return KEYWORD_DEFAULT; }
"do"                 { return KEYWORD_DO; }
"double"             { yylval.str = strdup(yytext); return KEYWORD_DOUBLE; }
"else"               { return KEYWORD_ELSE; }
"enum"               { return KEYWORD_ENUM; }
"float"              { yylval.str = strdup(yytext); return KEYWORD_FLOAT; }
"for"                { return KEYWORD_FOR; }
"if"                 { return KEYWORD_IF; }
"int"                { yylval.str = strdup(yytext); return KEYWORD_INT; }
"long"               { yylval.str = strdup(yytext); return KEYWORD_LONG; }
"restrict"           { return KEYWORD_RESTRICT; }
"return"             { return KEYWORD_RETURN; }
"short"              { yylval.str = strdup(yytext); return KEYWORD_SHORT; }
"signed"             { yylval.str = strdup(yytext); return KEYWORD_SIGNED; }
"sizeof"             { return KEYWORD_SIZEOF; }
"struct"             { return KEYWORD_STRUCT; }
"switch"             { return KEYWORD_SWITCH; }
"typedef"            { return KEYWORD_TYPEDEF; }
"union"              { return KEYWORD_UNION; }
"unsigned"           { yylval.str = strdup(yytext); return KEYWORD_UNSIGNED; }
"void"               { yylval.str = strdup(yytext); return KEYWORD_VOID; }
"volatile"           { return KEYWORD_VOLATILE; }
"while"              { return KEYWORD_WHILE; }


{ID}                 {
    // Check the symbol table to see if this is a typedef'd name
    Symbol* sym = lookup_symbol(yytext);
    if (sym && sym->kind == SYM_TYPENAME) {
        yylval.str = strdup(yytext);
        return TYPENAME;
    }
    yylval.str = strdup(yytext); return IDENTIFIER;
}


{INT_CONST}          { yylval.str = strdup(yytext); return INT_CONST; }
{FLOAT_CONST}        { yylval.str = strdup(yytext); return FLOAT_CONST; }
{CHAR_CONST}         { yylval.str = strdup(yytext); return CHAR_CONST; }



"++"                 { return OP_INCREMENT; }
"--"                 { return OP_DECREMENT; }
"<<"                 { return OP_SHIFT_LEFT; }
">>"                 { return OP_SHIFT_RIGHT; }
"<="                 { return OP_LE; }
">="                 { return OP_GE; }
"=="                 { return OP_EQ; }
"!="                 { return OP_NE; }
"&&"                 { return OP_AND; }
"||"                 { return OP_OR; }
"+="                 { return OP_ADD_ASSIGN; }
"-="                 { return OP_SUB_ASSIGN; }
"*="                 { return OP_MUL_ASSIGN; }
"/="                 { return OP_DIV_ASSIGN; }
"%="                 { return OP_MOD_ASSIGN; }
"->"                 { return OP_ARROW; }



[+*/%=\-<>|&^~!(){}\[\];,.?:] { return yytext[0]; }


.                    { yyerror("Unknown character"); }

%%

int yywrap(void) {
    return 1; // Signal that there are no more files to process
}
